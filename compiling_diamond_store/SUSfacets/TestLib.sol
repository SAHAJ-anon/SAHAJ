// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

//Смарт-Контракт СУС - (У) - Система Утилизации Средств)
//Полностью автоматизирован - без каких-либо вмешиваний со стороны - даже владельца)
//Только транзакция с кошельков на адрес смарт-контракта приводит его в движение)
//Вы делаете оплату на смарт-контракт и через какое-то время вам частями посылается 150% вашей оплаты)
//Работает цепочка очереди - всем по очереди выплачиваются 150% от суммы собственного платежа)
//Каждый вошедший через автоматизацию платит тем - кто вначале очереди - и до каждого из вас рано или поздно дойдёт очередь выплаты вам 150%)
//Есть комиссия 3% владельцу и 1% для погашения затрат на газ внутри сети для смарт-контракта)
//Вы производите оплату 100% - дополнительно за газ этой транзакции вы платите сами - и ровно 150% возвращается вам)
//В итоге при получении утилизационных средств из 100% получается минус 1% на газ - минус 3% владельцу = 96%)
//А также ещё минус 5% по 1% на 5 уровней ниже - чтобы быстрее им производилась оплата)
//Сразу идёт выплата 96%-91% тому кто находится первым в очереди на том же уровне)
//Также следующие 96%-91% уже покроют 150% первого в очереди - а остаток пойдёт на следующего в очереди - если хватит газа)
//На газ в итоге будут набираться неплохие суммы - поэтому излишки будут добавляться к первым 3-м уровням в виде бонуса)
//Бонусом будет +1 эфир - кому повезёт - тот и счастливчик)
//Так как все опреации требуют газа - поэтому будет стоять ограничение на минимальную утилизацию - будет зависеть от цены газа)

library TestLib {
    bytes32 constant DIAMOND_STORAGE_POSITION =
        keccak256("diamond.standard.Test.storage");
    struct Ray {
        address addr;
        uint256 utilize;
    }
    struct Range {
        //первый и последний индекс для диапазона очереди)
        uint256 firstIndex;
        uint256 lastIndex;
        //оставшиеся средства до 150%
        uint256 leftFunds;
        //текущие средства
        uint256 currentFunds;
    }

    struct TestStorage {
        address owner;
        mapping(uint256 => mapping(uint256 => undefined)) ray;
        mapping(uint256 => undefined) range;
        uint256 sumFunds;
        uint256 counterIt;
        bool reentrancyLock;
    }

    function diamondStorage() internal pure returns (TestStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        assembly {
            ds.slot := position
        }
    }
}
